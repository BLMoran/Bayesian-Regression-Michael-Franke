---
title: "BRMS cheat sheet: common things to do with BRMS"
subtitle: "Bayesian regression: theory & practice"
author: "Michael Franke"
format: html
editor: visual
execute:
  error: false
  warning: false
  message: false
  cache: true
callout-appearance: simple
---

This document provides a cursory run-down of common operations and manipulations for working with the `brms` package.

# Preamble

{{< include 00-preamble.qmd >}}

# Running a regression model

As a running example, we fit a multi-level model.

```{r}
#| results: hide

fit_MC <- 
  brms::brm(
    # "brmsformula" object specifies the model to fit
    formula = RT ~ condition + (1 + condition + shape | submission_id),
    # data to fit model to
    data = aida::data_MC_preprocessed |> 
      mutate(condition = factor(as.character(block), 
                                levels = c("goNoGo", "reaction", "discrimination"))),
    # "iter" is the number of iterations
    iter = 4000,
    # control parameters for MCMC
    control = list(adapt_delta = 0.9)
  )
```

## Updating a model

[ fill me ]{style="color:darkgreen"}

# Inspecting the model

[ fill me ]{style="color:darkgreen"}

-   summary stats, tidy ...
-   shinystan

## Retrieve names of model variables

```{r }
tidybayes::get_variables(fit_MC)
```

# MCMC diagnostics

[ fill me ]{style="color:darkgreen"}

# Extracting samples

[ fill me ]{style="color:darkgreen"}

## Tidy samples with `tidybayes`

Retrieve all samples with `tidybayes::tidy_draws()`:

```{r}
tidybayes::tidy_draws(fit_MC)
```

## Getting summaries for samples

To get (Bayesian) summary statistics for a vector of samples from a parameter you can do this:

```{r}
posterior_Intercept <- 
  tidybayes::tidy_draws(fit_MC) |> 
  dplyr::pull("b_Intercept")
```

The `tidybayes::hdi` function gives the upper and lower bound of a Bayesian credible interval:

```{tidybayes::hdi(posterior_Intercept, credMass = 0.90)}
```

The function `aida::summarize_sample_vector` does so, too.

```{r}
aida::summarize_sample_vector(posterior_Intercept, name = "Intercept")
```

# Plotting posteriors

[ fill me ]{style="color:darkgreen"}

-   population and group level effects

# Posterior predictives

## Visual PPCs

## Extracting samples from the posterior predictive distribution

[ fill me ]{style="color:darkgreen"}

# Priors

## Inspecting default priors without running the model

```{r}
# define the model as a "brmsformula" object
myFormula <- brms::bf(RT ~ 1 + block + (1 + block | submission_id))

# get prior information
brms::get_prior(
  formula = myFormula,
  data    = aida::data_MC_preprocessed,
  family  = exgaussian()
  )

```

[ explain what that means ]{style="color:darkgreen"}

## Setting priors

[ fill me ]{style="color:darkgreen"}

## Sampling from the prior

[ fill me ]{style="color:darkgreen"}

## Prior predictive checks

# Under the hood: Stan code, design matrices etc.

## Extract the Stan code

```{r}
brms::stancode(fit_MC)
```

## Extract Stan data

This is the data passed to Stan. Useful for inspecting dimensions etc.

```{r}
brms::standata(fit_MC) |> names()
```

## Inspect design matrices

### Population-level effects

```{r}
X <- brms::standata(fit_MC)$X
X |> head()
```

### Group-level effects

The group-level design matrix is spread out over different variables (all names `Z_` followed by some indices), but retrievable like so:

```{r}
data4Stan <- brms::standata(fit_MC)
Z <- data4Stan[str_detect(data4Stan |> names(), "Z_")] |> as_tibble()
Z
```
